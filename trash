
	/**
	 * <b><code>LDr</code> method.</b> This method is equivalent to the action
	 * of LDA, LDX, LD1, etc., of MIXAL. (12/24/16)
	 */
	private void LDr(Register reg) {
		Word w = computeV();
		reg.setRegister(w);
	}

	/**
	 * <b>LDrN method.</b> This method is equivalent to the action of LDAN,
	 * LDXN, LD1N, etc., of MIXAL. (12/24/16)
	 */
	private void LDrN(Register reg) {
		Word w = computeV();
		w.setSign(!w.getSign());
		reg.setRegister(w);
	}

	/**
	 * <b><code>STr</code> method.</b> This method is equivalent to the action
	 * of STA, STX, ST1, etc., of MIXAL. (12/24/16)
	 */
	private void STr(Register reg) {
		Word w = reg.getWord();
		int field = myBytes[3].getValue();
		int left = field / 8;
		int right = field % 8;
		int M = computeM();
		for (int i = 5, j = right; j >= left; i--, j--) {
			MIX.memory[M].setByte(i, w.getByte(j));
		}
	}

	/**
	 * <b><code>STZ</code> method.</b> This method is equivalent to the action
	 * of STZ of MIXAL. I initially thought about simply creating a simulator.register
	 * stored with 0 and using the STr method, but I figured that would be too
	 * contrived. I might change my mind though because the code is literally
	 * the same thing. (12/24/16)
	 */
	private void STZ() {
		Word w = new Word();
		int field = myBytes[3].getValue();
		int left = field / 8;
		int right = field % 8;
		int M = computeM();
		for (int i = 5, j = right; j >= left; i--, j--) {
			MIX.memory[M].setByte(i, w.getByte(j));
		}
	}

	/**
	 * <b><code>ADD</code> method.</b> This method is equivalent to the ADD
	 * operator in MIXAL (12/24/16).
	 * 
	 * TODO: Code has uhh no aesthetics?
	 */
	private void ADD(boolean switchSign) {
		boolean overflow = false;
		Word V = computeV();
		if(switchSign) {
			V.setSign(!V.getSign());
		}
		Word W = MIX.rA.getWord();
		if(V.getSign() == W.getSign()) {
			for(int i = 5; i >= 1; i--) {
				int sum;
				sum = V.getByte(i).getValue() + W.getByte(i).getValue();
				if(overflow)
					sum += 1;
				W.setByte(i, new Byte(sum));
				if(sum >= 64) {
					overflow = true;
				}
			}
		}
		else {
			boolean sign = true;
			boolean isSame = true;
			for(int i = 1; i <= 5; i--) {
				if(V.getByte(i).compareTo(W.getByte(i)) > 0) {
					sign = V.getSign();
					isSame = false;
					break;
				}
				else if(V.getByte(i).compareTo(W.getByte(i)) < 0) {
					sign = W.getSign();
					isSame = false;
					break;
				}
			}
			if(isSame) {
				for(int i = 1; i <= 5; i++) {
					W.setByte(i, new Byte(0));
				}
			}
			else {
				int[] a = new int[5];
				for(int i = 5; i >= 1; i--) {
					a[i - 1] = (sign ? 1 : -1) * ((W.getSign() ? 1 : -1) * (W.getByte(i).getValue()) + (V.getSign() ? 1 : -1) * (V.getByte(i).getValue()));
				}
				for(int i = 5; i >= 1; i--) {
					if(a[i - 1] < 0) {
						a[i - 1] += 64;
						a[i - 2] -= 1;
					}
				}
				Word w = new Word();
				for(int i = 5; i >= 1; i--) {
					w.setByte(i, new Byte(a[i-1]));
				}
				MIX.rA.setRegister(w);
			}
		}
		MIX.overflowToggle = overflow;
		MIX.rA.setRegister(W);
	}

	public void MUL() {
		int V = computeV().getValue();
		int W = MIX.rA.getValue();
		
	}
